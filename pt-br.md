# Tome cuidado com a função findOne

De acordo com a [OWASP Top 10 de 2017](https://www.owasp.org/index.php/Top_10-2017_Top_10), a vulnerabilidade mais encontrada no último ano foi a [A1:2017-Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection), que se refere a injeção de um código malicioso em um determinado ponto de um sistema vulnerável, a exploração mais conhecida é a SQL Injection, onde através de URLs, formulários conseguimos enviar consultas maliciosas no banco de dados da vítima.

Hoje em dia, é normal encontrarmos sistemas que possuam uma API para autenticar um usuário e que utilizam um banco não relacional para armazenar essas informações, um banco muito utilizado é o [Mongo](https://www.mongodb.com/).

No exemplo abaixo, foi utilizado o banco [NeDB](https://github.com/louischatriot/nedb#finding-documents) que possui uma sintaxe muito parecida com o Mongo em suas consultas.

**controller**
```javascript
exports.login = async (req, reply) => {
    try {
        let { user, pass } = req.body

        let result = await findOne({user, pass})

        return reply.code(200).send(result)
    } catch (e) {
        return reply.code(500).send({ success: false, result: 'user/pass not found' })
    }
}
```

db.**findOne**
```javascript
async function findOne(query) {
    return new Promise((resolve, reject) => {
        db.findOne(query, (err, result) => {
            if (err) return reject(err)

            resolve({ success: true, result })
        })
    })
}
```
![](https://i.imgur.com/RQB8lPB.png)

O login foi efetuado pois o objeto que passamos para o banco foi um objeto válido, ou seja, tanto o **user** quanto o **pass** possuem valores que realmente existem no banco.

No começo desse post eu comentei sobre SQL Injection, mas você já ouviu falar em NoSQL Injection? Não? Certo, você já vai entender o que é isso, veja a função abaixo:
```javascript

db.findOne(query, (err, result) => {
    if (err) return reject(err)

    resolve({ success: true, result })
})
```

Basicamente o que essa função faz é uma verificação no banco para saber se existe algum registro com os valores que informamos para o **user** && **pass**, note bem que usei o operador lógico **&&** (and).

Isso não te faz pensar que, se passarmos pelo menos o **user** válido e no lugar do pass informarmos uma outra validação que retorne **TRUE**, a função vai funcionar?

Tanto o Mongo quanto o NeDB, possuem filtros que podem ser utilizados nas consultas no banco, por exemplo o **$gt** ele é o equivalente ao operador relacional “**>**” vejam abaixo o resultado.

![](https://i.imgur.com/6npi4xl.png)

Ou seja, fizemos uma consulta no banco perguntando se ele possui um registro com o **user** "wubba" e que o valor do **pass** seja maior do que "nada", se existe um usuário com esse nome, é claro que a senha será maior do que "nada". Se passarmos o mesmo objeto `{"$gt":""}` no **user** e **pass**, o banco vai retornar o primeiro registro que ele tiver!

Isso nos mostra que a função **findOne** é perigosa se não criarmos tratamentos para os valores que são utilizados nela, nesse caso, o ideal é validar se as informações que estão sendo informadas não são objetos.

Para tratarmos isso, podemos utilizar a seguinte função

**controller**
```javascript
exports.loginProtected = async (req, reply) => {
    try {
        let { user, pass } = req.body
        await isObject({ user, pass })

        let result = await findOne({user, pass})

        return reply.code(200).send(result)
    } catch (e) {
        return reply.code(500).send({ success: false, result: 'user/pass not found' })
    }
}
```

**isObject**
```javascript
async function isObject(params) {
    return new Promise((resolve, reject) => {
        Object.keys(params).forEach((v, i) => {
            if (typeof params[v] === 'object') return reject(false)
        })
        resolve(true)
    })
}
```

Esse caso foi reproduzido usando o banco [NeDB](https://github.com/louischatriot/nedb#finding-documents), mas também foi simulado usando [Mongo](https://docs.mongodb.com/manual/reference/method/db.collection.findOne/)e [Sails/Waterline](https://sailsjs.com/documentation/reference/waterline-orm/models/find-one)
